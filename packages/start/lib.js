const fs = require('fs');
const path = require('path');
const resolve = require('resolve');
const dotenv = require('dotenv');
const WebpackDevServer = require('webpack-dev-server');
const noopServiceWorkerMiddleware = require('react-dev-utils/noopServiceWorkerMiddleware');
const clearConsole = require('react-dev-utils/clearConsole');
const {
  choosePort,
  prepareUrls,
} = require('react-dev-utils/WebpackDevServerUtils');

const ConsoleUtilities = require('@4c/cli-core/ConsoleUtilities');
const createCompiler = require('./createCompiler');

let webpack;
try {
  // eslint-disable-next-line import/no-unresolved, import/no-extraneous-dependencies
  webpack = require('webpack');
} catch (err) {
  webpack = resolve.sync('webpack', { cwd: process.cwd() });
}

const DEFAULT_PORT = parseInt(process.env.PORT, 10) || 3000;
const HOST = process.env.HOST || '0.0.0.0';

module.exports = async options => {
  try {
    if (options.env) {
      const { parsed, error } = dotenv.load({ path });
      if (error) throw error;
      Object.entries(parsed).forEach(([key, value]) => {
        process.env[key] = value;
      });
    }

    let config = require(path.resolve(options.config || 'webpack.config'));

    if (typeof config === 'function') {
      config = config({}, { ...options, mode: 'development' });
    }
    if (!config.mode) {
      config.mode = 'development';
    }

    const devServerConfig = config.devServer || {};
    // We attempt to use the default port but if it is busy, we offer the user to
    // run on a different port. `choosePort()` Promise resolves to the next free port.
    const port = await choosePort(HOST, devServerConfig.port || DEFAULT_PORT);

    if (port == null) {
      return;
    }

    const protocol = process.env.HTTPS === 'true' ? 'https' : 'http';

    const appName =
      config.name || require(path.resolve('./package.json')).name;

    const useTypeScript = fs.existsSync(`tsconfig.json`);

    const urls = prepareUrls(protocol, HOST, port);

    const devSocket = {
      warnings: warnings =>
        // eslint-disable-next-line no-use-before-define
        devServer.sockWrite(devServer.sockets, 'warnings', warnings),
      errors: errors =>
        // eslint-disable-next-line no-use-before-define
        devServer.sockWrite(devServer.sockets, 'errors', errors),
    };

    // Create a webpack compiler that is configured with custom messages.
    const compiler = createCompiler({
      appName,
      config,
      devSocket,
      urls,
      useTypeScript,
      webpack,
      progress: options.progress,
    });

    const { proxy } = config.devServer;
    // Serve webpack assets generated by the compiler over a web server.
    const serverConfig = {
      disableHostCheck: !proxy,
      compress: true,
      clientLogLevel: 'none',
      watchContentBase: true,
      hot: true,
      quiet: true,
      publicPath: config.output.publicPath,
      before(app) {
        // This service worker file is effectively a 'no-op' that will reset any
        // previous service worker registered for the same host:port combination.
        // We do this in development to avoid hitting the production cache if
        // it used the same host and port.
        // https://github.com/facebook/create-react-app/issues/2272#issuecomment-302832432
        app.use(noopServiceWorkerMiddleware());
      },
      ...config.devServer,
    };

    const devServer = new WebpackDevServer(compiler, serverConfig);

    devServer.listen(port, HOST, err => {
      if (err) {
        ConsoleUtilities.error(err);
        return;
      }

      if (options.progress && ConsoleUtilities.isTTY) {
        clearConsole();
      }
    });

    const exit = () => {
      devServer.close();
      process.exit();
    };

    process.on('SIGINT', exit).on('SIGTERM', exit);
  } catch (err) {
    if (err && err.message) {
      ConsoleUtilities.error(err.message);
    }
    process.exit(1);
  }
};
